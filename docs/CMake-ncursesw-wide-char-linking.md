# **Linking with libncursesw for Wide Character Support in CMake Projects**

The ncurses library is a fundamental tool for creating text-based user interfaces in terminal environments. When developing applications that require the display and manipulation of a wide range of characters, including those beyond the basic ASCII set, it becomes necessary to utilize the wide character version of this library, typically referred to as ncursesw. CMake, a widely adopted cross-platform build system, provides mechanisms to locate and link against such libraries. This report details the steps and considerations involved in ensuring a program built with CMake is correctly linked to libncursesw for proper wide character support.

**1\. Introduction to Wide Character Support with ncurses**

Standard ncurses primarily handles single-byte characters. For applications needing to work with Unicode and other multi-byte character encodings, ncursesw offers the necessary extensions and functions.1 This includes the ability to display characters from various languages and special symbols. Properly linking against libncursesw is crucial for the correct rendering and input of these characters in terminal-based applications. CMake facilitates this process through its modular design and built-in functionalities for finding external libraries.

**2\. Utilizing CMake's FindCurses Module**

CMake provides a dedicated module, FindCurses, designed to locate the curses or ncurses library on a system.3 This module defines several variables that can be used to determine if the library was found, the location of its header files, and the names of the library files themselves. To specifically target the ncursesw library for wide character support, CMake leverages the CURSES\_NEED\_WIDE variable.4

**3\. Configuring CMakeLists.txt for libncursesw**

To ensure your CMake project links against libncursesw, you need to modify your CMakeLists.txt file to instruct the FindCurses module to look for the wide character version. This is achieved by setting the CURSES\_NEED\_WIDE variable to TRUE before calling the find\_package(Curses) command. Additionally, setting CURSES\_NEED\_NCURSES to TRUE ensures that the module specifically searches for the ncurses family of libraries.1 A basic example of how to configure your CMakeLists.txt is as follows:

```cmake
cmake_minimum_required(VERSION 3.10) # Or higher, as CURSES_NEED_WIDE was added in 3.10
project(my_terminal_app)

set(CURSES_NEED_NCURSES TRUE)
set(CURSES_NEED_WIDE TRUE)
find_package(Curses REQUIRED)

include_directories(${CURSES_INCLUDE_DIRS})
add_executable(my_terminal_app main.c)
target_link_libraries(my_terminal_app ${CURSES_LIBRARIES})
```
The CURSES\_NEED\_WIDE variable serves as a directive to the FindCurses module, guiding it to prioritize locating the ncursesw library. By establishing this requirement before the find\_package invocation, the developer ensures that CMake first attempts to find the wide character enabled version. The separation of CURSES\_NEED\_NCURSES and CURSES\_NEED\_WIDE within CMake's design allows for precise control over the specific variant of the curses library being sought. This distinction acknowledges that certain projects might only necessitate the fundamental functionalities of ncurses, while others demand the extended capabilities offered by ncursesw for handling a broader range of characters. This design choice within CMake reflects an understanding that different projects have varying needs regarding character encoding support, leading to a more efficient and targeted library search and linking process. The necessity of setting these variables prior to the execution of find\_package underscores the declarative nature of CMake scripting. Developers are essentially stating their prerequisites to CMake, which then endeavors to fulfill them during the configuration phase of the build process. This specific ordering is critical because find\_package is the command that initiates the actual search for the library. CMake must be informed about the desired library variant (ncursesw through CURSES\_NEED\_WIDE) before it commences its search.

**4\. Verifying the Linkage**

After configuring the CMake project, it is essential to verify that the program is indeed linked against libncursesw. One way to do this is to examine the generated build files, such as Makefiles or Ninja build files, or the CMake cache file (CMakeCache.txt).5 The CURSES\_LIBRARIES variable defined by the FindCurses module will typically contain the path to the library that CMake has identified. If libncursesw was successfully located, this variable should reflect its path, for example, /usr/lib/libncursesw.so. During the actual compilation and linking stage, the linker commands should include an option like \-lncursesw (the exact format might vary slightly depending on the operating system and linker). Furthermore, on Unix-like systems, tools such as ldd can be used on the compiled executable to list its dynamic dependencies, which should include libncursesw.so.5 Similarly, on macOS, the otool \-L command can provide the same information. Simply configuring CMake is not a guarantee of correct linkage; it's crucial to actively confirm that the intended library, libncursesw, is the one being used by the application. The availability of multiple verification methods highlights the intricate nature of the build and link process. Each tool offers a different perspective and level of detail, aiding in the diagnosis of potential issues at various stages. Examining the CMake cache reveals what CMake discovered during the configuration phase. Inspecting the linker commands shows the instructions given to the compiler for linking. Finally, analyzing the built executable confirms the libraries that are actually linked at runtime. This layered approach to verification is vital for ensuring the correct dependencies are in place. The reliance on operating system-specific tools like ldd and otool emphasizes the fundamental role of the underlying operating system in dynamic linking. While CMake strives to provide a cross-platform build configuration, the final act of linking is performed by the system's linker. Consequently, understanding how the linker operates on the target platform and how to interpret its output is essential for effectively troubleshooting linking problems.

**5\. Troubleshooting Common Scenarios**

Several common scenarios can arise when trying to link against libncursesw. Understanding these issues and their solutions can save significant development time.

* **Scenario 1: CMake cannot find Curses:** If the find\_package(Curses) command fails, it indicates that CMake was unable to locate the necessary header files or library files.7 This often occurs because the development packages for ncurses (which include ncursesw) are not installed on the system. On Debian or Ubuntu-based systems, the solution is typically to install the package libncursesw5-dev or libncurses6-dev using the system's package manager (e.g., sudo apt-get install libncursesw5-dev). Similarly, on Red Hat or CentOS systems, the package to install is usually ncurses-devel (e.g., sudo yum install ncurses-devel). The precise name of the package might differ depending on the specific Linux distribution being used. In less common situations where ncursesw is installed in a non-standard location, you might need to provide CMake with hints about the installation paths using variables like CMAKE\_INCLUDE\_PATH and CMAKE\_LIBRARY\_PATH. However, this approach is generally less portable than allowing find\_package to work automatically by ensuring the development packages are installed in standard system locations.7 In some instances, particularly on older systems or with specific configuration setups, temporarily setting the variable CURSES\_USE\_NCURSES to TRUE before calling find\_package might assist CMake in locating the library.7 The dependency on system-level package managers for libraries like ncursesw underscores the crucial role of the operating system in providing essential development tools. CMake relies on these system-level installations to function correctly. CMake itself is a build system generator; it does not inherently manage package dependencies. Therefore, when find\_package fails to locate a library, it often signifies that the required system package is missing, and the user needs to install it using their distribution's package management tools.
* **Scenario 2: Linking against the wrong library (libncurses instead of libncursesw):** If the CURSES\_NEED\_WIDE variable is not set to TRUE before the find\_package(Curses) call, CMake might default to finding and linking against the standard libncurses library, which does not include wide character support.1 The default behavior of the FindCurses module, when CURSES\_NEED\_WIDE is not explicitly set, is to search for the more basic curses or ncurses library. To rectify this, it is essential to ensure that the line set(CURSES\_NEED\_WIDE TRUE) appears in your CMakeLists.txt file *before* the line that calls find\_package(Curses).1 The order in which commands are placed within CMake files is significant. Setting variables before invoking functions that depend on those variables is a fundamental principle of CMake scripting. CMake processes the CMakeLists.txt file sequentially. Consequently, the find\_package command will use the value assigned to CURSES\_NEED\_WIDE at the exact moment it is executed. Therefore, the set command must precede the find\_package command to have the intended effect of instructing CMake to look for the wide character version of the library.
* **Scenario 3: Platform-specific issues (e.g., OpenBSD):** On certain operating systems, such as OpenBSD, the way ncurses is packaged might differ from other systems. For instance, both the standard and wide character versions might share the same primary header file (ncurses.h), and there might not be a distinct ncursesw header directory.8 In such scenarios, you might need to adjust your CMake configuration based on the specific platform. This could involve adding conditional logic using CMake's if command and the CMAKE\_SYSTEM\_NAME variable to handle OpenBSD differently, potentially by setting CURSES\_USE\_NCURSES to TRUE and ensuring that the search paths include the standard header location.8 Cross-platform build systems like CMake aim to abstract away the differences between operating systems, but occasionally, the unique characteristics of a particular operating system's library packaging require specific handling within the build configuration. While CMake offers a unified approach to configuring builds across various platforms, the actual library installations and system conventions can vary. In cases like OpenBSD, where the standard packaging deviates from the norm, developers might need to introduce platform-specific logic into their CMake configuration files to ensure that the correct library is discovered and linked.
* **Scenario 4: Linker errors (e.g., "undefined reference to mvwaddwstr"):** Encountering linker errors, particularly those indicating an "undefined reference" to wide character functions like mvwaddwstr, often signifies that the program code is attempting to use these functions but is being linked against the standard libncurses library, which does not provide their implementations.10 This situation typically arises when the code includes calls to functions specific to the wide character version of the library, but the linker is only finding the single-byte character version. The primary cause is usually that the CURSES\_NEED\_WIDE variable was not set to TRUE in the CMake configuration, leading to the linkage with the default libncurses. The solution is to ensure that set(CURSES\_NEED\_WIDE TRUE) is present *before* the find\_package(Curses) call in your CMakeLists.txt file, thus forcing CMake to look for and link against libncursesw.10 After making this change to the CMake configuration, it is crucial to clean the build directory, which usually involves deleting the build folder or removing the CMakeCache.txt file, and then re-running CMake to regenerate the build files based on the updated configuration.10 This ensures that the changes to the CMake settings are properly processed and reflected in the subsequent build process. The build process consists of distinct phases: configuration, compilation, and linking. Errors can occur at any of these stages, and understanding the type of error, such as a linker error, provides valuable clues about the underlying problem. A linker error specifically indicates that while the compiler successfully translated the source code into object files, the linker, responsible for combining these object files with the necessary libraries, could not find the definition for a particular function. In this context, an "undefined reference" error to a wide character function suggests a mismatch between the functions used in the program's code (which are wide character functions) and the library that the linker is attempting to use (which is the standard ncurses library).
* **Scenario 5: Issues with locale settings:** Even after successfully linking against libncursesw, proper rendering and handling of wide characters might still require setting the correct locale within the application code itself. This is typically done using the setlocale(LC\_ALL, "") function, which configures the program's locale settings based on the environment.2 This step is essential for informing the ncursesw library about the character encoding that should be used for displaying and interpreting wide characters. This is not a CMake configuration issue but a runtime requirement for enabling wide character support within the terminal environment. Achieving full wide character support involves both the correct build configuration (linking against libncursesw using CMake) and the proper setup of the runtime environment (configuring the locale within the application code). These two aspects must be correctly configured and working in tandem for the application to handle wide characters as expected. Linking against libncursesw provides the necessary library functions for wide character operations, but the terminal itself needs to be configured to correctly interpret and display Unicode characters. Setting the locale ensures that the application and the terminal are in agreement regarding the character encoding being used.

**Table 1: Common Issues and Solutions**

| Issue | Potential Cause(s) | Recommended Solution(s) |
| :---- | :---- | :---- |
| CMake cannot find Curses | Development packages not installed | Install libncursesw5-dev or libncurses6-dev (Debian/Ubuntu), ncurses-devel (Red Hat/CentOS), or equivalent. |
| Linking against libncurses instead of libncursesw | CURSES\_NEED\_WIDE not set to TRUE in CMakeLists.txt | Add set(CURSES\_NEED\_WIDE TRUE) before find\_package(Curses). |
| Linker error: undefined reference to wide char function | Linked against libncurses instead of libncursesw | Ensure set(CURSES\_NEED\_WIDE TRUE) is set in CMakeLists.txt, clean build directory, and re-run CMake. |
| Incorrect display of wide characters | Locale not set correctly in the application code | Add setlocale(LC\_ALL, "") at the beginning of your main function or before initializing ncurses. |
| Platform-specific issues (e.g., OpenBSD) | Unique packaging of ncurses on the operating system | Adjust CMake configuration with platform-specific logic (e.g., using if(CMAKE\_SYSTEM\_NAME MATCHES "OpenBSD")). |

**6\. Advanced Considerations (Optional)**

While the standard approach using FindCurses and CURSES\_NEED\_WIDE is generally sufficient, there are some advanced considerations. One such consideration is manually specifying the library paths. Although generally not recommended for maintaining portability across different systems, in certain specific scenarios, you might choose to directly set the CURSES\_LIBRARY\_DIRS and CURSES\_LIBRARIES variables in CMake to point to the exact location of your libncursesw installation.7 It is important to note that this method can make your build system less adaptable to different environments, as the file paths for libraries can vary significantly between operating systems and even different installations on the same system. Another approach involves utilizing pkg-config, a utility that provides a standardized way to retrieve information about installed libraries, including the necessary compiler and linker flags.12 If your system provides pkg-config files for ncursesw, you can integrate it into your CMake configuration using the pkg\_search\_module command. For example:

```cmake
find_package(PkgConfig REQUIRED)
pkg_search_module(NCURSESW REQUIRED ncursesw)
include_directories(${NCURSESW_INCLUDE_DIRS})
link_directories(${NCURSESW_LIBRARY_DIRS})
target_link_libraries(my_terminal_app ${NCURSESW_LIBRARIES})
```
Package configuration tools like pkg-config offer a consistent mechanism for obtaining compiler and linker flags for libraries. Integrating with such tools can often simplify the CMake configuration process, particularly when dealing with more complex dependencies that have numerous requirements. pkg-config acts as an intermediary, providing details about installed libraries in a uniform format. This allows build systems like CMake to query this information and automatically configure the necessary compiler and linker settings, thereby reducing the need for manual specification of these details. In situations where the standard FindCurses module does not adequately address your specific requirements or the nuances of a particular platform, you have the option of creating a custom CMake module, for instance, named FindNcursesw.cmake, to explicitly search for the libncursesw library.14 This is a more advanced technique that requires a deeper understanding of how CMake modules are developed and how they function within the build process.

**7\. Best Practices and Recommendations**

To ensure a smooth experience when linking against libncursesw in your CMake projects, it is advisable to follow these best practices:

* Always include the lines set(CURSES\_NEED\_NCURSES TRUE) and set(CURSES\_NEED\_WIDE TRUE) in your CMakeLists.txt file *before* the find\_package(Curses) command to explicitly request the wide character version of the library.1
* Verify that the development packages for ncursesw are installed on your development system.
* After configuring your CMake project, always verify the linkage by inspecting the CURSES\_LIBRARIES variable in the CMake cache and by checking the linker flags used during the build process.
* Whenever you make changes to your CMakeLists.txt file related to library linking, it is good practice to clean your build directory (remove CMakeCache.txt and any generated build files) and then re-run CMake to ensure the changes are properly applied.10
* Within your application's source code, remember to set the locale using the setlocale(LC\_ALL, "") function before you initialize the ncurses library.2
* For the sake of better portability across different systems and environments, it is generally recommended to avoid manually specifying library paths in your CMake configuration unless it is absolutely necessary. Instead, prefer using CMake's built-in find\_package mechanism, which is designed to handle library discovery in a more robust and platform-independent way.
* Consider exploring the use of pkg-config as an alternative method for finding and linking against ncursesw, especially if your system provides appropriate configuration files for this library.12

**8\. Conclusion**

For applications requiring the display and manipulation of a broad range of characters in terminal interfaces, linking against the libncursesw library is essential. CMake provides the necessary tools to achieve this through the FindCurses module and the crucial CURSES\_NEED\_WIDE variable. By setting CURSES\_NEED\_NCURSES and CURSES\_NEED\_WIDE to TRUE before calling find\_package(Curses) in your CMakeLists.txt, you instruct CMake to locate and link against the wide character version of the ncurses library. It is important to verify the linkage and to be aware of common troubleshooting scenarios to ensure that your application correctly supports wide characters. Following the recommended best practices will contribute to a more robust and portable build process for your terminal-based applications.

#### **Works cited**

1. Modules/FindCurses.cmake · v3.24.0-rc2 \- GitLab, accessed May 2, 2025, [https://colibrigitlab.leica-geosystems.com/open-source/cmake/-/blob/v3.24.0-rc2/Modules/FindCurses.cmake?ref\_type=tags](https://colibrigitlab.leica-geosystems.com/open-source/cmake/-/blob/v3.24.0-rc2/Modules/FindCurses.cmake?ref_type=tags)
2. Unicode 7 in CentOS 7 TUI Code \- LinuxJedi's /dev/null, accessed May 2, 2025, [https://linuxjedi.co.uk/unicode-7-in-centos-7-tui-code/](https://linuxjedi.co.uk/unicode-7-in-centos-7-tui-code/)
3. FindCurses — CMake 3.0.2 Documentation, accessed May 2, 2025, [https://cmake.org/cmake/help/v3.0/module/FindCurses.html](https://cmake.org/cmake/help/v3.0/module/FindCurses.html)
4. FindCurses — CMake 4.0.1 Documentation, accessed May 2, 2025, [https://cmake.org/cmake/help/latest/module/FindCurses.html](https://cmake.org/cmake/help/latest/module/FindCurses.html)
5. ccmake: does not support ncursesw (\#19033) · Issue \- GitLab, accessed May 2, 2025, [https://gitlab.kitware.com/cmake/cmake/-/issues/19033](https://gitlab.kitware.com/cmake/cmake/-/issues/19033)
6. CMake pick ncurses (no unicode support) instead of ncursesw (with unicode support) · Issue \#219 · gnudatalanguage/gdl \- GitHub, accessed May 2, 2025, [https://github.com/gnudatalanguage/gdl/issues/219](https://github.com/gnudatalanguage/gdl/issues/219)
7. CMake can't find Curses \- Stack Overflow, accessed May 2, 2025, [https://stackoverflow.com/questions/4678926/cmake-cant-find-curses](https://stackoverflow.com/questions/4678926/cmake-cant-find-curses)
8. OpenBSD 6.9 ncursesw header detection with FIND\_PACKAGE(Curses) (\#22218) \- GitLab, accessed May 2, 2025, [https://gitlab.kitware.com/cmake/cmake/-/issues/22218](https://gitlab.kitware.com/cmake/cmake/-/issues/22218)
9. \[CMake\] FindCurses wide, accessed May 2, 2025, [https://cmake.org/pipermail/cmake/2010-February/035460.html](https://cmake.org/pipermail/cmake/2010-February/035460.html)
10. C \- configure cmake to propely link ncursesw \- Stack Overflow, accessed May 2, 2025, [https://stackoverflow.com/questions/48252152/c-configure-cmake-to-propely-link-ncursesw](https://stackoverflow.com/questions/48252152/c-configure-cmake-to-propely-link-ncursesw)
11. Adding wide character support breaks ncurses menu \- Stack Overflow, accessed May 2, 2025, [https://stackoverflow.com/questions/79015305/adding-wide-character-support-breaks-ncurses-menu](https://stackoverflow.com/questions/79015305/adding-wide-character-support-breaks-ncurses-menu)
12. weechat/cmake/FindNcurses.cmake at main \- GitHub, accessed May 2, 2025, [https://github.com/weechat/weechat/blob/master/cmake/FindNcurses.cmake](https://github.com/weechat/weechat/blob/master/cmake/FindNcurses.cmake)
13. using ncursesw (with wide characters) : r/C\_Programming \- Reddit, accessed May 2, 2025, [https://www.reddit.com/r/C\_Programming/comments/p0goey/using\_ncursesw\_with\_wide\_characters/](https://www.reddit.com/r/C_Programming/comments/p0goey/using_ncursesw_with_wide_characters/)
14. luanti/cmake/Modules/FindNcursesw.cmake at master · luanti-org ..., accessed May 2, 2025, [https://github.com/minetest/minetest/blob/master/cmake/Modules/FindNcursesw.cmake](https://github.com/minetest/minetest/blob/master/cmake/Modules/FindNcursesw.cmake)
